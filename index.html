<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>固定布局 + RWD 漢堡選單</title>
  <style>
      * {
          box-sizing: border-box;
          margin: 0;
          padding: 0;
      }
      
      body {
          font-family: Arial, sans-serif;
          background: #f5f5f5;
      }

      button {
          padding: 12px 25px;
          background-color: #3498db;
          color: white;
          border: none;
          border-radius: 50px;
          cursor: pointer;
          font-size: 16px;
          font-weight: 600;
          transition: all 0.3s;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      button:disabled {
          background-color: #bdc3c7;
          color: #7f8c8d;
          cursor: not-allowed;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      /* --- 公共樣式 --- */
      .menu-top, .menu-bottom, .menu-bottom-second, .menu-left {
          background: #3DA5FF;
          color: #fff;
          border-radius: 10px;
          padding: 15px;
          gap: 10px;
      }

      /* --- 固定位置 --- */
      .menu-top {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .menu-bottom-second {
        background: none;
        position: fixed;
        bottom: 50px;
        left: 0;
        right: 0;
        height: 50px;
        z-index: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .menu-bottom {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 50px;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .menu-left {
          position: fixed;
          top: 70px; /* 預留 top 高度 */
          bottom: 110px; /* 預留兩個 bottom 菜單的高度 */
          left: 0;
          width: 30%;
          max-width: 290px;
          z-index: 900;
          transition: transform 0.3s ease;
          display: flex;
          flex-direction: column;
      }

      .menu-left.hidden {
        transform: translateX(-100%);
      }

      /* --- content --- */
      .content {
          margin-top: 70px;
          margin-bottom: 110px; /* 調整為兩個底部菜單的總高度 */
          margin-left: 30%;
          padding: 20px;
          background: #fff;
          min-height: 100vh;
          transition: margin-left 0.3s ease;
          overflow: hidden; /* 隱藏超出content的部分 */
      }

        /* --- 漢堡按鈕 --- */
        .hamburger {
          display: flex;
          position: fixed;
          top: 15px;
          left: 15px;
          width: 35px;
          height: 28px;
          flex-direction: column;
          justify-content: space-between;
          cursor: pointer;
          z-index: 1100;
        }
        .hamburger span {
          display: block;
          height: 4px;
          background: #fff;
          border-radius: 2px;
        }

        /* --- RWD < 800px --- */
        @media (max-width: 800px) {
          .menu-left {
            width: 290px;
            transform: translateX(-100%);
          }
          .menu-left.open {
            transform: translateX(0);
          }
          .content {
            margin-left: 0;
          }
        }


        /*-- 滑鼠拖曳 --*/
      .neck-container-wrapper {
          position: relative;
          width: 100%;
          max-width: 600px;
          aspect-ratio: 1 / 2;
          border: 2px solid #3498db;
          border-radius: 10px;
          overflow: hidden;
          background-color: rgba(255, 255, 255, 0.8);
          background-image: url('./頸部計算/病患側面.png');
          background-size: cover;
          background-position: top;
          background-repeat: no-repeat;
          box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
      }
      
      #neck-container {
          position: absolute;
          width: 80%;
          aspect-ratio: 1 / 1.5;
          background-color: rgba(236, 240, 241, 0.7);
          opacity: 0.7;
          border: 2px dashed #7f8c8d;
          border-radius: 10px;
          top: 5%;
          left: 10%;
          /* cursor: move; */
          /*touch-action: none;
          user-select: none;*/
          z-index: 2;
      }
      
      .point {
          position: absolute;
          width: 20px;
          height: 20px;
          border: 2px solid #3DA5FF;
          background-color: #3DA5FF;
          border-radius: 50%;
          transform: translate(-50%, -50%);
          cursor: pointer;
          box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
          transition: transform 0.2s, box-shadow 0.2s;
          /* 添加數字顯示樣式 */
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          font-size: 12px;
          font-weight: bold;
          text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
      }
      
      .point.draggable {
          animation: pulse 1.5s infinite;
          box-shadow: 0 0 20px #3DA5FF;
      }
      
      .point.draggable:hover {
          transform: translate(-50%, -50%) scale(1.5);
      }

      @keyframes pulse {
          0% {
              background-color: #3DA5FF;
              box-shadow: 0 0 20px #3DA5FF, 0 0 40px #3DA5FF;
              transform: translate(-50%, -50%) scale(1);
          }
          50% {
              background-color: white;
              box-shadow: 0 0 30px white, 0 0 60px rgba(255, 255, 255, 0.8);
              transform: translate(-50%, -50%) scale(1.3);
          }
          100% {
              background-color: #3DA5FF;
              box-shadow: 0 0 20px #3DA5FF, 0 0 40px #3DA5FF;
              transform: translate(-50%, -50%) scale(1);
          }
      }

      /* 連接線樣式 */
      .connection-line {
          position: absolute;
          height: 2px;
          background: transparent;
          border-top: 2px dashed #e74c3c;
          z-index: 1;
          transform-origin: left center;
          pointer-events: none;
      }

      /* 特殊線條樣式 */
      .special-line {
          position: absolute;
          background: #2ecc71;
          z-index: 1;
          pointer-events: none;
      }

      .horizontal-line {
          height: 2px;
          border-top: 2px solid #2ecc71;
      }

      .vertical-line {
          width: 2px;
          border-left: 2px solid #2ecc71;
      }

      .diagonal-line {
          height: 2px;
          border-top: 2px solid #2ecc71;
          transform-origin: left center;
      }

      /* 交點樣式 */
      .intersection-point {
          position: absolute;
          width: 12px;
          height: 12px;
          border: 2px solid #f39c12;
          background-color: #f39c12;
          border-radius: 50%;
          transform: translate(-50%, -50%);
          z-index: 3;
          box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
      }

      
</style>
</head>
<body>

<div class="menu-top"></div>
<div class="menu-left" id="menuLeft">
  <button>拍照上傳</button>
  <button>頸部計算</button>
</div>
<!-- 漢堡按鈕 -->
<div class="hamburger" id="hamburger">
  <span></span>
  <span></span>
  <span></span>
</div>

<div class="content">
      <div class="neck-container-wrapper">
          <div id="neck-container">
              <!-- 點位顯示區,並拖曳 -->
          </div>
      </div>
</div>


<div class="menu-bottom-second">
  <button id="zoom-in-btn">+</button>
  <button id="zoom-out-btn">-</button>
  <span>&nbsp;&nbsp;&nbsp;</span>
  <button id="prev-btn"><</button>
  <button id="next-btn">></button>
</div>

<div class="menu-bottom">
  <button id="calculate-btn">計算</button>
  <span>&nbsp;&nbsp;&nbsp;</span>
  <button id="reset-btn">重置</button>
</div>

<script>
const hamburger = document.getElementById('hamburger');
const menuLeft = document.getElementById('menuLeft');
const content = document.querySelector('.content');

hamburger.addEventListener('click', () => {
  // 檢查螢幕寬度
  if (window.innerWidth <= 800) {
    // 小螢幕：切換open class
    menuLeft.classList.toggle('open');
  }
  // 大螢幕：切換hidden class
  else {
    menuLeft.classList.toggle('hidden');
    // 同時調整content的margin
    if (menuLeft.classList.contains('hidden')) {
      content.style.marginLeft = '0';
    } else {
      content.style.marginLeft = '30%';
    }
  }
});



// 點擊選單以外的區域關閉選單（僅在小螢幕且選單開啟時）
document.addEventListener('click', (e) => {
  // 只在小螢幕且選單開啟時處理
  if (window.innerWidth <= 800 && menuLeft.classList.contains('open')) {
    // 如果點擊的不是選單或漢堡按鈕或它們的子元素
    if (!menuLeft.contains(e.target) && !hamburger.contains(e.target)) {
      menuLeft.classList.remove('open');
    }
  }
});



document.addEventListener('DOMContentLoaded', function() {
          const neckContainer = document.getElementById('neck-container');
          const neckContainerWrapper = document.querySelector('.neck-container-wrapper');
          const currentPointElement = document.getElementById('current-point');
          const statusElement = document.getElementById('status');
          const prevBtn = document.getElementById('prev-btn');
          const nextBtn = document.getElementById('next-btn');
          const resetBtn = document.getElementById('reset-btn');
          const calculateBtn = document.getElementById('calculate-btn');
          const zoomInBtn = document.getElementById('zoom-in-btn');
          const zoomOutBtn = document.getElementById('zoom-out-btn');
          
          // 縮放比例變量
          let currentScale = 1;
          const minScale = 0.5;
          const maxScale = 2.0;
          const scaleStep = 0.1;
          
          // 五个点的初始位置（相对于容器的比例位置）
          const pointPositions = [
              { x: 0.3, y: 0.1 },  // 顶部
              { x: 0.35, y: 0.2 },  // 左侧
              { x: 0.37, y: 0.3 },  // 右侧
              { x: 0.3, y: 0.41 },  // 左下
              { x: 0.24, y: 0.52 }   // 右下
          ];
          
          let points = [];
          let currentPointIndex = 0;
          let isDragging = false;
          let startX, startY;
          let initialPoints = [];
          
          // 初始化点
          function initPoints() {
              neckContainer.innerHTML = '';
              points = [];
              
              pointPositions.forEach((pos, index) => {
                  const point = document.createElement('div');
                  point.className = 'point';
                  point.id = `point-${index}`;
                  
                  // 添加白色數字
                  point.textContent = index + 1;
                  
                  // 根据容器大小计算点的位置
                  point.style.left = `${pos.x * 100}%`;
                  point.style.top = `${pos.y * 100}%`;
                  
                  neckContainer.appendChild(point);
                  points.push(point);
                  
                  // 保存初始位置
                  initialPoints.push({
                      x: pos.x * neckContainer.offsetWidth,
                      y: pos.y * neckContainer.offsetHeight
                  });
                  
                  // 添加拖拽事件
                  point.addEventListener('mousedown', startDrag);
                  point.addEventListener('touchstart', startDrag, { passive: false });
              });
              
              // 设置第一个点为可拖拽状态
              setDraggablePoint(0);
          }
          
          // 设置当前可拖拽的点
          function setDraggablePoint(index) {
              points.forEach((point, i) => {
                  if (i === index) {
                      point.classList.add('draggable');
                  } else {
                      point.classList.remove('draggable');
                  }
              });
              
              currentPointIndex = index;
              if (currentPointElement) {
                  currentPointElement.textContent = index + 1;
              }
              
              // 根據當前點的位置設定按鈕狀態
              if (index === 0) {
                  prevBtn.disabled = true;
              } else {
                  prevBtn.disabled = false;
              }
              
              if (index === points.length - 1) {
                  nextBtn.disabled = true;
              } else {
                  nextBtn.disabled = false;
              }
              
              if (statusElement) {
                  statusElement.textContent = `請拖動第 ${index + 1} 個點`;
              }
          }
          
          // 开始拖拽点
          function startDrag(e) {
              const point = e.target;
              if (!point.classList.contains('draggable')) return;
              
              e.preventDefault();
              isDragging = true;
              
              // 鼠标事件和触摸事件处理
              const clientX = e.touches ? e.touches[0].clientX : e.clientX;
              const clientY = e.touches ? e.touches[0].clientY : e.clientY;
              
              startX = clientX - point.offsetLeft;
              startY = clientY - point.offsetTop;
              
              document.addEventListener('mousemove', drag);
              document.addEventListener('touchmove', drag, { passive: false });
              document.addEventListener('mouseup', stopDrag);
              document.addEventListener('touchend', stopDrag);
          }
          
          // 拖拽点
          function drag(e) {
              if (!isDragging) return;
              
              e.preventDefault();
              const point = points[currentPointIndex];
              
              const clientX = e.touches ? e.touches[0].clientX : e.clientX;
              const clientY = e.touches ? e.touches[0].clientY : e.clientY;
              
              // 计算新位置（限制在容器内）
              let newX = clientX - startX;
              let newY = clientY - startY;
              
              // 限制点在容器范围内
              newX = Math.max(0, Math.min(neckContainer.offsetWidth - 10, newX));
              newY = Math.max(0, Math.min(neckContainer.offsetHeight - 10, newY));
              
              point.style.left = `${newX}px`;
              point.style.top = `${newY}px`;
          }
          
          // 停止拖拽
          function stopDrag() {
              isDragging = false;
              document.removeEventListener('mousemove', drag);
              document.removeEventListener('touchmove', drag);
              document.removeEventListener('mouseup', stopDrag);
              document.removeEventListener('touchend', stopDrag);
          }
          
          // 下一个点
          nextBtn.addEventListener('click', function() {
              if (currentPointIndex < points.length - 1) {
                  setDraggablePoint(currentPointIndex + 1);
              }
          });
          
          // 上一个点
          prevBtn.addEventListener('click', function() {
              if (currentPointIndex > 0) {
                  setDraggablePoint(currentPointIndex - 1);
              }
          });
          
          // 重置
          resetBtn.addEventListener('click', function() {
              // 先重置縮放
              applyScale(1);
              // 再初始化點位
              initPoints();
              setDraggablePoint(0);
              nextBtn.disabled = false;
              if (statusElement) {
                  statusElement.textContent = "已重置，請拖動第一個點";
              }
              // 清除所有線條和交點
              clearAllLines();
          });

          // 計算按鈕
          calculateBtn.addEventListener('click', function() {
              calculateSpecialLines();
          });

          // 清除所有線條和交點
          function clearAllLines() {
              const existingLines = neckContainer.querySelectorAll('.connection-line, .special-line, .intersection-point');
              existingLines.forEach(element => element.remove());
          }

          // 計算特殊線條和交點
          function calculateSpecialLines() {
              // 清除之前的線條和交點
              clearAllLines();

              // 獲取所有點的位置
              const pointPositions = [];
              for (let i = 0; i < points.length; i++) {
                  const point = points[i];
                  const actualX = point.style.left.includes('%') ? 
                      (parseFloat(point.style.left) / 100) * neckContainer.offsetWidth : 
                      parseFloat(point.style.left);
                  const actualY = point.style.top.includes('%') ? 
                      (parseFloat(point.style.top) / 100) * neckContainer.offsetHeight : 
                      parseFloat(point.style.top);
                  
                  pointPositions.push({
                      x: actualX, // 點已經通過 CSS transform: translate(-50%, -50%) 居中，不需要額外偏移
                      y: actualY
                  });
              }

              // 1. 畫點1與點4的連線
              drawDiagonalLine(pointPositions[0], pointPositions[3], 'line14');

              // 2. 畫點3的水平線
              const horizontalLine = drawHorizontalLine(pointPositions[2]);

              // 3. 畫點5的垂直線
              const verticalLine = drawVerticalLine(pointPositions[4]);

              // 4. 計算水平線3與線14的交點（點6）
              const intersection6 = calculateLineIntersection(
                  pointPositions[2], 'horizontal',
                  pointPositions[0], pointPositions[3]
              );
              if (intersection6) {
                  drawIntersectionPoint(intersection6, '6');
              }

              // 5. 計算水平線3與垂直線5的交點（點7）
              const intersection7 = {
                  x: pointPositions[4].x,
                  y: pointPositions[2].y
              };
              drawIntersectionPoint(intersection7, '7');

              // 6. 畫點5與點6的連線
              if (intersection6) {
                  drawDiagonalLine(pointPositions[4], intersection6, 'line56');
                  
                  // 7. 計算角度756（點7-點5-點6的夾角）
                  const angle756 = calculateAngle756(intersection7, pointPositions[4], intersection6);
                  
                  // 8. 計算線75和線56的距離
                  const distance75 = calculateDistance(intersection7, pointPositions[4]);
                  const distance56 = calculateDistance(pointPositions[4], intersection6);
                  
                  // 顯示所有計算結果
                  const results = [
                      `角度756 (點7-點5-點6): ${angle756.toFixed(1)}°`,
                      `線75距離: ${distance75.toFixed(2)}px`,
                      `線56距離: ${distance56.toFixed(2)}px`
                  ];
                  alert("計算結果:\n" + results.join('\n'));
              }
          }

          // 畫對角線
          function drawDiagonalLine(point1, point2, className) {
              const line = document.createElement('div');
              line.className = `special-line diagonal-line ${className}`;

              const length = Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
              const angle = Math.atan2(point2.y - point1.y, point2.x - point1.x) * 180 / Math.PI;

              line.style.left = point1.x + 'px';
              line.style.top = point1.y + 'px';
              line.style.width = length + 'px';
              line.style.transform = `rotate(${angle}deg)`;

              neckContainer.appendChild(line);
              return line;
          }

          // 畫水平線
          function drawHorizontalLine(point) {
              const line = document.createElement('div');
              line.className = 'special-line horizontal-line';

              line.style.left = '0px';
              line.style.top = point.y + 'px';
              line.style.width = neckContainer.offsetWidth + 'px';

              neckContainer.appendChild(line);
              return line;
          }

          // 畫垂直線
          function drawVerticalLine(point) {
              const line = document.createElement('div');
              line.className = 'special-line vertical-line';

              line.style.left = point.x + 'px';
              line.style.top = '0px';
              line.style.height = neckContainer.offsetHeight + 'px';

              neckContainer.appendChild(line);
              return line;
          }

          // 計算線段交點
          function calculateLineIntersection(horizontalPoint, horizontalType, diagonalPoint1, diagonalPoint2) {
              if (horizontalType === 'horizontal') {
                  // 水平線的 y 坐標
                  const y = horizontalPoint.y;
                  
                  // 對角線的參數方程
                  const dx = diagonalPoint2.x - diagonalPoint1.x;
                  const dy = diagonalPoint2.y - diagonalPoint1.y;
                  
                  if (dy === 0) return null; // 對角線也是水平線，無交點
                  
                  // 計算參數 t
                  const t = (y - diagonalPoint1.y) / dy;
                  
                  if (t >= 0 && t <= 1) {
                      // 交點在對角線段內
                      const x = diagonalPoint1.x + t * dx;
                      return { x, y };
                  }
              }
              return null;
          }

          // 畫交點
          function drawIntersectionPoint(point, label) {
              const intersectionPoint = document.createElement('div');
              intersectionPoint.className = 'intersection-point';
              intersectionPoint.textContent = label;
              intersectionPoint.style.left = point.x + 'px';
              intersectionPoint.style.top = point.y + 'px';
              intersectionPoint.style.color = 'white';
              intersectionPoint.style.fontSize = '10px';
              intersectionPoint.style.fontWeight = 'bold';
              intersectionPoint.style.display = 'flex';
              intersectionPoint.style.alignItems = 'center';
              intersectionPoint.style.justifyContent = 'center';

              neckContainer.appendChild(intersectionPoint);
          }

          // 計算角度756（點7-點5-點6的夾角）
          function calculateAngle756(point7, point5, point6) {
              // 計算向量57 (從點5到點7)
              const vector57 = {
                  x: point7.x - point5.x,
                  y: point7.y - point5.y
              };
              
              // 計算向量56 (從點5到點6)
              const vector56 = {
                  x: point6.x - point5.x,
                  y: point6.y - point5.y
              };
              
              // 計算兩個向量的夾角
              const dotProduct = vector57.x * vector56.x + vector57.y * vector56.y;
              const magnitude57 = Math.sqrt(vector57.x * vector57.x + vector57.y * vector57.y);
              const magnitude56 = Math.sqrt(vector56.x * vector56.x + vector56.y * vector56.y);
              
              // 避免除零錯誤
              if (magnitude57 === 0 || magnitude56 === 0) {
                  return 0;
              }
              
              // 計算角度（弧度）
              const cosAngle = dotProduct / (magnitude57 * magnitude56);
              // 確保cosAngle在[-1, 1]範圍內，避免浮點誤差
              const clampedCosAngle = Math.max(-1, Math.min(1, cosAngle));
              const angleRadians = Math.acos(clampedCosAngle);
              
              // 轉換為度數
              const angleDegrees = angleRadians * 180 / Math.PI;
              
              return angleDegrees;
          }

          // 計算兩點之間的距離
          function calculateDistance(point1, point2) {
              const dx = point2.x - point1.x;
              const dy = point2.y - point1.y;
              return Math.sqrt(dx * dx + dy * dy);
          }
          
          // 縮放功能
          function applyScale(scale) {
              neckContainerWrapper.style.transform = `scale(${scale})`;
              neckContainerWrapper.style.transformOrigin = 'center top';
              currentScale = scale;
              
              // 更新按鈕狀態
              zoomInBtn.disabled = (scale >= maxScale);
              zoomOutBtn.disabled = (scale <= minScale);
          }
          
          // 放大按鈕
          zoomInBtn.addEventListener('click', function() {
              const newScale = Math.min(currentScale + scaleStep, maxScale);
              applyScale(newScale);
          });
          
          // 縮小按鈕
          zoomOutBtn.addEventListener('click', function() {
              const newScale = Math.max(currentScale - scaleStep, minScale);
              applyScale(newScale);
          });
          
          // 初始化
          initPoints();
          
          // 初始化縮放按鈕狀態
          applyScale(1);
          
          /*
          // 添加容器拖拽功能
          let containerDragging = false;
          let containerStartX, containerStartY;
          let initialContainerLeft, initialContainerTop;
          
          neckContainer.addEventListener('mousedown', startContainerDrag);
          neckContainer.addEventListener('touchstart', startContainerDrag, { passive: false });
          
          function startContainerDrag(e) {
              // 如果点击的是点，则不拖拽容器
              if (e.target.classList.contains('point')) return;
              
              containerDragging = true;
              const clientX = e.touches ? e.touches[0].clientX : e.clientX;
              const clientY = e.touches ? e.touches[0].clientY : e.clientY;
              
              containerStartX = clientX;
              containerStartY = clientY;
              
              initialContainerLeft = parseInt(window.getComputedStyle(neckContainer).left);
              initialContainerTop = parseInt(window.getComputedStyle(neckContainer).top);
              
              document.addEventListener('mousemove', containerDrag);
              document.addEventListener('touchmove', containerDrag, { passive: false });
              document.addEventListener('mouseup', stopContainerDrag);
              document.addEventListener('touchend', stopContainerDrag);
          }
          
          function containerDrag(e) {
              if (!containerDragging) return;
              
              e.preventDefault();
              const clientX = e.touches ? e.touches[0].clientX : e.clientX;
              const clientY = e.touches ? e.touches[0].clientY : e.clientY;
              
              const deltaX = clientX - containerStartX;
              const deltaY = clientY - containerStartY;
              
              neckContainer.style.left = `${initialContainerLeft + deltaX}px`;
              neckContainer.style.top = `${initialContainerTop + deltaY}px`;
          }
          
          function stopContainerDrag() {
              containerDragging = false;
              document.removeEventListener('mousemove', containerDrag);
              document.removeEventListener('touchmove', containerDrag);
              document.removeEventListener('mouseup', stopContainerDrag);
              document.removeEventListener('touchend', stopContainerDrag);
          }
          */
          
      });
</script>

</body>
</html>
